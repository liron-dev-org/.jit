rules:
  - id: double-free
    patterns:
    - pattern-not: |
        free($VAR);
        ...
        $VAR = NULL;
        ...
        free($VAR);
    - pattern-not: |
        free($VAR);
        ...
        $VAR = malloc(...);
        ...
        free($VAR);
    - pattern-inside: |
        free($VAR);
        ...
        $FREE($VAR);
    - metavariable-pattern:
        metavariable: $FREE
        pattern: free
    - focus-metavariable: $FREE
    message: >-
      Variable '$VAR' was freed twice. This can lead to undefined behavior.
    metadata:
      cwe:
      - 'CWE-415: Double Free'
      owasp:
      - A03:2021 - Injection
      - A01:2017 - Injection
      references:
      - https://cwe.mitre.org/data/definitions/415.html
      - https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory
      category: security
      technology:
      - c
      confidence: MEDIUM
      subcategory:
      - vuln
      likelihood: LOW
      impact: HIGH
    languages: [c]
    severity: ERROR
  - id: function-use-after-free
    patterns:
      - pattern-either:
        - pattern: $FUNC(..., <... $VAR ...>, ...)
        - pattern: $FUNC(..., <... $VAR->$ACCESSOR ...>, ...)
        - pattern: $FUNC(..., <... (*$VAR).$ACCESSOR ...>, ...)
        - pattern: $FUNC(..., <... $VAR[$NUM] ...>, ...)
      - metavariable-regex:
          metavariable: $FUNC
          regex: (?!^free$)
      - pattern-inside:
          free($VAR);
          ...
      - pattern-not-inside:
          free($VAR);
          ...
          $VAR = NULL;
          ...
      - pattern-not-inside:
          free($VAR);
          ...
          $VAR = malloc(...);
          ...
    message: Variable '$VAR' was passed to a function after being freed. This can lead to undefined behavior.
    metadata:
      cwe:
        - "CWE-416: Use After Free"
      references:
        - https://cwe.mitre.org/data/definitions/416.html
        - https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free/
      category: security
      technology:
        - c
      confidence: MEDIUM
      cwe2022-top25: true
      cwe2021-top25: true
      subcategory:
        - vuln
      likelihood: LOW
      impact: HIGH
    languages:
      - c
    severity: ERROR
  - id: buffer-overflow-strcpy-stpcpy-strcat
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/676
        - https://cwe.mitre.org/data/definitions/120
        - https://cwe.mitre.org/data/definitions/787
        - https://g.co/kgs/PCHQjJ
      confidence: HIGH
    message: >-
      A buffer overflow condition exists when a program attempts to put
      more data in a buffer than it can hold, or when a program attempts to
      put data in a memory area outside of the boundaries of a buffer.
    severity: ERROR
    languages:
      - c
      - cpp
    patterns:
      - pattern-either:
          - pattern: strcpy(...)
          - pattern: stpcpy(...)
          - pattern: strcat(...)
          - pattern: wcscpy(...)
          - pattern: wcpcpy(...)
          - pattern: wcscat(...)
      - pattern-not: $FUN($BUF, "...", ...)
  - id: command-injection
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/676
        - https://cwe.mitre.org/data/definitions/78
        - https://cwe.mitre.org/data/definitions/88
        - https://g.co/kgs/PCHQjJ
        - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
      confidence: HIGH
    message: >-
      The software constructs an OS command using externally-influenced input,
      but it does not neutralize or incorrectly neutralizes special elements
      that could modify the intended OS command.
    severity: ERROR
    languages:
      - c
      - cpp
    patterns:
      - pattern-either:
          - pattern: system(...)
          - pattern: popen(...)
      - pattern-not: $FUN("...", ...)
  - id: insecure-use-strtok-fn
    pattern: strtok(...)
    message: >-
      The strtok() function is unsafe in concurrent environments. strtok() modifies
      the input string by replacing delimiters with null bytes and maintains internal
      state between calls, making it unsafe in threads or asynchronous code. Instead,
      use the thread-safe alternative strtok_r(), which doesn't modify the original
      string and maintains its state via a user-supplied pointer. This replacement
      enhances both the safety and predictability of your code, mitigating risks
      related to concurrent execution and string corruption.
    metadata:
      cwe:
      - 'CWE-676: Use of Potentially Dangerous Function'
      references:
      - https://wiki.sei.cmu.edu/confluence/display/c/STR06-C.+Do+not+assume+that+strtok%28%29+leaves+the+parse+string+unchanged
      - https://man7.org/linux/man-pages/man3/strtok.3.html#BUGS
      - https://stackoverflow.com/a/40335556
      category: security
      technology:
      - c
      confidence: LOW
      subcategory:
      - audit
      likelihood: LOW
      impact: HIGH
    languages: [c]
    severity: ERROR
  - id: buffer-overflow-gets
    pattern: gets(...)
    message: >-
      The gets() function is inherently insecure due to its inability to prevent
      buffer overflows. gets() reads input without checking buffer boundaries, potentially
      allowing an attacker to overwrite memory. Replace gets() with safer alternatives like
      fgets() or gets_s(). fgets() is widely supported and allows specifying buffer size,
      while gets_s() is a C11 standard function designed as a secure replacement for gets().
      Using these alternatives helps prevent buffer overflows and enhances the security of your application.
    metadata:
      cwe:
      - 'CWE-676: Use of Potentially Dangerous Function'
      references:
      - https://us-cert.cisa.gov/bsi/articles/knowledge/coding-practices/fgets-and-gets_s
      category: security
      technology:
      - c
      confidence: MEDIUM
      subcategory:
      - audit
      likelihood: LOW
      impact: HIGH
    languages: [c]
    severity: ERROR
  - id: use-after-free
    patterns:
      - pattern-either:
        - pattern: $VAR->$ACCESSOR
        - pattern: (*$VAR).$ACCESSOR
        - pattern: $VAR[$NUM]
      - pattern-inside:
          free($VAR);
          ...
      - pattern-not-inside:
          $VAR = NULL;
          ...
      - pattern-not-inside:
          free($VAR);
          ...
          $VAR = malloc(...);
          ...
    message: >-
      Variable '$VAR' was used after being freed. Program accesses memory via a pointer after that
      memory has been freed. This can lead to crashes, data corruption, or security breaches.
      To prevent this, ensure pointers are set to NULL or reassigned to valid memory after a free() call.
      Proper pointer and memory management is crucial for secure and stable applications.
    metadata:
      cwe:
        - "CWE-416: Use After Free"
      references:
        - https://cwe.mitre.org/data/definitions/416.html
        - https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free/
      category: security
      technology:
        - c
      confidence: MEDIUM
      cwe2022-top25: true
      cwe2021-top25: true
      subcategory:
        - vuln
      likelihood: LOW
      impact: HIGH
    languages:
      - c
    severity: ERROR
  - id: validate-setuid-seteuid-results
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/252
        - https://lwn.net/Articles/451985/
        - https://www.usenix.org/legacy/events/sec02/full_papers/chen/chen.pdf
      confidence: MEDIUM
    message: >-
      The software does not check the return value from a method or
      function, which can prevent it from detecting unexpected states and
      conditions. If the program calls a function to drop privileges but
      does not check the return code to ensure that privileges were
      successfully dropped, then the program will continue to operate with
      the higher privileges.
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - patterns:
          - pattern: setuid(...)
          - pattern-not-inside: $RET = setuid(...)
          - pattern-not-inside: <... setuid(...) == $VAL ...>
          - pattern-not-inside: <... setuid(...) != $VAL ...>
          - pattern-not-inside: <... setuid(...) < $VAL ...>
          - pattern-not-inside: <... !setuid(...) ...>
          - pattern-not-inside: return setuid(...);
      - patterns:
          - pattern: seteuid(...)
          - pattern-not-inside: $RET = seteuid(...)
          - pattern-not-inside: <... seteuid(...) == $VAL ...>
          - pattern-not-inside: <... seteuid(...) != $VAL ...>
          - pattern-not-inside: <... seteuid(...) < $VAL ...>
          - pattern-not-inside: <... !seteuid(...) ...>
          - pattern-not-inside: return seteuid(...);
  - id: unsafe-ret-strlcpy-strlcat
    metadata:
      references:
        - https://lwn.net/Articles/507319/
        - https://g.co/kgs/PCHQjJ
      confidence: MEDIUM
    message: >-
      The strlcpy() and strlcat() functions return the total length of the
      string they tried to create. For strlcpy() that means the length of
      the source string. For strlcat() that means the initial length of the
      destination string plus the length of of the source string.
      Therefore, this return value can be larger than the size of the
      destination buffer. If it is used unsafely, e.g. as an index to write
      to the destination buffer, memory corruption might occur.
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - pattern: $RET = strlcpy(...)
      - pattern: $RET = strlcat(...)
      - pattern: $RET = wcslcpy(...)
      - pattern: $RET = wcslcat(...)
      - pattern: $RET += strlcpy(...)
      - pattern: $RET += strlcat(...)
      - pattern: $RET += wcslcpy(...)
      - pattern: $RET += wcslcat(...)
  - id: integer-overflow-strlen
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/190
        - https://cwe.mitre.org/data/definitions/680
        - https://github.com/struct/mms
      confidence: MEDIUM
    message: >-
      The software performs a calculation that can produce an integer
      overflow or wraparound, when the logic assumes that the resulting
      value will always be larger than the original value. This can
      introduce other weaknesses when the calculation is used for resource
      management or execution control. When influenced by the size of an
      input it is often easier to overflow a short than an int.
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - pattern: (short $LEN) = strlen(...);
      - pattern: (short int $LEN) = strlen(...);
      - pattern: (unsigned short $LEN) = strlen(...);
      - pattern: (unsigned short int $LEN) = strlen(...);
      - pattern: (short $LEN) = wcslen(...);
      - pattern: (short int $LEN) = wcslen(...);
      - pattern: (unsigned short $LEN) = wcslen(...);
      - pattern: (unsigned short int $LEN) = wcslen(...);
  - id: off-by-one
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/193
        - https://cwe.mitre.org/data/definitions/787
        - https://g.co/kgs/PCHQjJ
        - https://github.com/struct/mms
      confidence: MEDIUM
    message: >-
      The software calculates or uses an incorrect maximum or minimum value
      that is 1 more, or 1 less, than the correct value.
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - pattern: $BUF[sizeof($BUF)] = $EXPR
      - patterns:
          - pattern: $BUF[$LEN] = $EXPR
          - pattern-inside: |
              $TYPE $BUF[$LEN];
              ...
              $BUF[$LEN] = $EXPR;
      - patterns:
          - pattern: |
              *($BUF + $LEN) = $EXPR
          - pattern-inside: |
              $TYPE $BUF[$LEN];
              ...
              *($BUF + $LEN) = $EXPR;
      - patterns:
          - pattern: $BUF[$X][$Y] = $EXPR
          - pattern-either:
              - pattern-inside: |
                  $TYPE $BUF[$A][$Y];
                  ...
                  $BUF[$X][$Y] = $EXPR;
              - pattern-inside: |
                  $TYPE $BUF[$X][$B];
                  ...
                  $BUF[$X][$Y] = $EXPR;
      - pattern: strlen($SRC) > sizeof($DST)
      - pattern: strlen($SRC) <= sizeof($DST)
      - pattern: sizeof($DST) < strlen($SRC)
      - pattern: sizeof($DST) >= strlen($SRC)
      - patterns:
          - pattern: strncat($DST, $SRC, $LEN)
          - metavariable-pattern:
              metavariable: $LEN
              patterns:
                - pattern-not: $VAL - 1
      - pattern: $STR[strlen($STR) - 1]
      - pattern: malloc(strlen($STR))
  - id: buffer-overflow-strncpy-stpncpy-strlcpy
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/806
        - https://github.com/0xdea/advisories/blob/master/2020-07-solaris-whodo-w.txt
        - https://dustri.org/b/playing-with-weggli.html
      confidence: MEDIUM
    message: >-
      Functions strncpy(), stpncpy(), and strlcpy() can cause buffer overflows if the destination
      buffer's remaining size is not correctly accounted for. This can lead to security vulnerabilities
      and data corruption. Ensure correct buffer size calculations and consider using safer string
      handling functions to mitigate this risk.
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - patterns:
          - pattern: $FUN($DST, $SRC, $LEN)
          - metavariable-pattern:
              metavariable: $FUN
              pattern-either:
                - pattern: strncpy
                - pattern: stpncpy
                - pattern: strlcpy
          - pattern-either:
              - pattern-inside: |
                  $TYPE $SRC[$LEN];
                  ...
              - pattern-inside: |
                  $TYPE $SRC[$LEN] = $EXPR;
                  ...
      - patterns:
          - pattern: $FUN($DST, $SRC, <... $SRC ...>)
          - metavariable-pattern:
              metavariable: $FUN
              pattern-either:
                - pattern: strncpy
                - pattern: stpncpy
                - pattern: strlcpy
  - id: overlapping-memory-sprintf-snprintf
    metadata:
      references:
        - https://linux.die.net/man/3/sprintf
      confidence: MEDIUM
    message: >-
      C standards specify that the results are undefined if a call to
      sprintf(), snprintf(), vsprintf(), or vsnprintf() would cause copying
      to take place between objects that overlap (e.g., if the target
      string array and one of the supplied input arguments refer to the
      same buffer).
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - pattern: sprintf($DST, ..., $DST, ...)
      - pattern: snprintf($DST, $N, ..., $DST, ...)
  - id: buffer-overflow-strncat
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/787
        - https://cwe.mitre.org/data/definitions/193
        - https://g.co/kgs/PCHQjJ
      confidence: HIGH
    message: >-
      The strncat() function can lead to buffer overflows if used incorrectly, similar to strcat().
      Misjudging the buffer's remaining size can result in writing past its end. Always calculate
      the buffer space correctly, accounting for the null terminator, to prevent security risks.
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - patterns:
          - pattern: strncat($DST, $SRC, $LEN)
          - pattern-either:
              - pattern-inside: |
                  $TYPE $DST[$LEN];
                  ...
              - pattern-inside: |
                  $TYPE $DST[$LEN] = $EXPR;
                  ...
      - pattern: strncat($DST, $SRC, sizeof($DST))
      - pattern: strncat($DST, $SRC, strlen($DST))
      - pattern: strncat($DST, $SRC, sizeof($DST) - strlen($DST))
  - id: setuid-setgid-ordering-errors
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/696
        - https://www.usenix.org/legacy/events/sec02/full_papers/chen/chen.pdf
        - https://g.co/kgs/PCHQjJ
        - https://github.com/struct/mms
      confidence: MEDIUM
    message: >-
      A compromised process might be able to regain elevated group privileges
      if set(e)gid() is called after set(e)uid(). A similar case is when
      privileges are temporarily dropped with seteuid() and then setuid() or
      seteuid() are called from while under unprivileged user.
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - patterns:
          - pattern: |
              setuid(...);
              ...
              setgid(...);
          - pattern-not: |
              setuid(0);
              ...
              setgid(...);
      - patterns:
          - pattern: |
              seteuid(...);
              ...
              setegid(...);
          - pattern-not: |
              seteuid(0);
              ...
              setegid(...);
          - pattern-not-inside: |
              seteuid(...);
              ...
              seteuid(0);
              ...
              setegid(...);
      - patterns:
          - pattern: |
              seteuid(...);
              ...
              setuid(...);
          - pattern-not: |
              seteuid(0);
              ...
              setuid(...);
          - pattern-not-inside: |
              seteuid(...);
              ...
              seteuid(0);
              ...
              setuid(...);
      - patterns:
          - pattern: |
              seteuid(...);
              ...
              seteuid(...);
          - pattern-not: |
              seteuid(0);
              ...
              seteuid(...);
          - pattern-not: |
              seteuid(...);
              ...
              seteuid(0);
          - pattern-not-inside: |
              seteuid(...);
              ...
              seteuid(0);
              ...
              seteuid(...);
  - id: improper-deallocation-free
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/590
        - https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_spirit.c
      confidence: MEDIUM
    message: >-
      The software calls free() on a pointer to memory that has a short
      lifetime and was not allocated using associated heap allocation
      functions such as malloc(), calloc(), or realloc().
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - patterns:
          - pattern: free($PTR)
          - pattern-either:
              - pattern-inside: |
                  $TYPE $PTR[$LEN];
                  ...
              - pattern-inside: |
                  $TYPE $PTR[$LEN] = $EXPR;
                  ...
              - pattern-inside: |
                  $TYPE $ARR[$LEN];
                  ...
                  $PTR = $ARR;
                  ...
              - pattern-inside: |
                  $TYPE $ARR[$LEN] = $EXPR;
                  ...
                  $PTR = $ARR;
                  ...
      - patterns:
          - pattern: free(&$VAR)
          - pattern-either:
              - pattern-inside: |
                  $TYPE $VAR;
                  ...
              - pattern-inside: |
                  $TYPE $VAR = $EXPR;
                  ...
              - pattern-inside: |
                  $TYPE $VAR[$LEN];
                  ...
              - pattern-inside: |
                  $TYPE $VAR[$LEN] = $EXPR;
                  ...
              - pattern-inside: |
                  $TYPE * $VAR;
                  ...
              - pattern-inside: |
                  $TYPE * $VAR = $EXPR;
                  ...
  - id: memset-argument-order
    metadata:
      references:
        - https://lkml.org/lkml/2009/11/11/336
        - https://bugs.mysql.com/bug.php?id=23181
      confidence: HIGH
    message: >-
      ncorrect argument order in memset() can result in ineffective memory initialization.
      Ensure that the character to set and the size arguments are correctly placed to avoid
      security risks and logical errors.
    severity: ERROR
    languages:
      - c
      - cpp
    pattern-either:
      - pattern: memset($S, $C, 0);
      - pattern: memset($S, $C, '\0');
      - pattern: memset($S, sizeof(...), $N);
      - pattern: memset_explicit($S, $C, 0);
      - pattern: memset_explicit($S, $C, '\0');
      - pattern: memset_explicit($S, sizeof(...), $N);
  - id: file-descriptor-exhaustion
    pattern-either:
    - patterns:
      - pattern: |
          $FD = open("/dev/urandom", ...);
          ...
          read($FD, ...);
      - pattern-not: |
          $FD = open("/dev/urandom", ...);
          ...
          $BYTES_READ = read($FD, ...);
    - patterns:
      - pattern: |
          $FD = open("/dev/random", ...);
          ...
          read($FD, ...);
      - pattern-not: |
          $FD = open("/dev/random", ...);
          ...
          $BYTES_READ = read($FD, ...);
    message: >-
      Call to 'read()' without error checking is susceptible to file descriptor
      exhaustion. Consider using the 'getrandom()' function.
    metadata:
      cwe:
      - 'CWE-774: Allocation of File Descriptors or Handles Without Limits or Throttling'
      references:
      - https://lwn.net/Articles/606141/
      category: security
      technology:
      - c
      confidence: MEDIUM
      subcategory:
      - audit
      likelihood: LOW
      impact: HIGH
    languages: [c]
    severity: ERROR
  - id: info-leak-on-non-formated-string
    message: >-
      Use %s, %d, %c... to format your variables, otherwise this could leak information.
    metadata:
      cwe:
      - 'CWE-532: Insertion of Sensitive Information into Log File'
      references:
      - http://nebelwelt.net/files/13PPREW.pdf
      category: security
      technology:
      - c
      confidence: MEDIUM
      owasp:
      - A09:2021 - Security Logging and Monitoring Failures
      subcategory:
      - audit
      likelihood: LOW
      impact: MEDIUM
    languages: [c]
    severity: ERROR
    pattern: printf(argv[$NUM]);
  - id: buffer-overflow-scanf-fn
    pattern: scanf(...)
    message: >-
      The use of scanf() without proper buffer boundary checks can cause buffer overflows.
      Replace it with safer functions like fgets() that respect buffer limits to enhance application security.
    metadata:
      cwe:
      - 'CWE-676: Use of Potentially Dangerous Function'
      references:
      - http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html
      category: security
      technology:
      - c
      confidence: LOW
      subcategory:
      - audit
      likelihood: LOW
      impact: HIGH
    languages: [c]
    severity: ERROR
  - id: buffer-overflow-strcat-fn
    pattern-either:
    - pattern: strcat(...)
    - pattern: strncat(...)
    message: >-
      The strcat() or strncat() functions can cause buffer overflows if not used carefully.
      Use strcat_s as a safer alternative to prevent memory corruption and maintain security integrity.
    metadata:
      cwe:
      - 'CWE-676: Use of Potentially Dangerous Function'
      references:
      - https://nvd.nist.gov/vuln/detail/CVE-2019-12553
      - https://techblog.mediaservice.net/2020/04/cve-2020-2851-stack-based-buffer-overflow-in-cde-libdtsvc/
      category: security
      technology:
      - c
      confidence: LOW
      subcategory:
      - audit
      likelihood: LOW
      impact: HIGH
    languages: [c]
    severity: ERROR
